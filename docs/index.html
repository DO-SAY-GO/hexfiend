<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hectic - Hexadecimal Crossword</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect x='2' y='2' width='60' height='60' rx='10' fill='%230b0f14' stroke='%235a8dff' stroke-width='4'/%3E%3Ctext x='32' y='43' text-anchor='middle' font-family='Menlo,Consolas,monospace' font-size='34' font-weight='700' fill='%235a8dff'%3EF%3C/text%3E%3C/svg%3E" />

<style>
@import url("https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@100;200&family=Source+Code+Pro:wght@200&display=swap");

:root{
  --bg:#0b0f14;
  --fg:#e7eef8;
  --muted:#90a4bc;
  --gridline:rgba(255,255,255,.12);
  --gold: rgba(255, 208, 90, .42);
  --failText:#ff6b85;

  --drag:rgba(255,196,69,.22);
  --ok:rgba(61,255,168,.26);
  --reveal:rgba(88,155,255,.26);
  --bad:rgba(255,86,125,.24);

  --N:7;
  --cell: clamp(24px, calc((100vw - 92px) / var(--N)), 44px);
  --font: clamp(13px, calc(var(--cell) * 0.46), 20px);

  /* UI mono */
  --mono: Menlo, "SF Mono", Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  /* Ultra-thin matrix stack */
  --matrix: "Roboto Mono", "Source Code Pro", Menlo, Monaco, Consolas, monospace;
}

*{ box-sizing:border-box; }

body{
  margin:0;
  min-height:100vh;
  background:
    radial-gradient(1100px 900px at 20% 10%, rgba(110,170,255,.12), transparent 52%),
    radial-gradient(1000px 800px at 80% 18%, rgba(60,255,170,.09), transparent 55%),
    var(--bg);
  color:var(--fg);
  font-family:system-ui,-apple-system,BlinkMacSystemFont;
  display:flex;
  justify-content:center;
  align-items:center;
  padding-top: env(safe-area-inset-top, 0px);
}

.app{
  width:100%;
  max-width:680px;
  padding: 132px 14px 14px;
}

.top{
  position: static;
  height: 0;
}

.title{
  position: fixed;
  text-align: center;
  top: 6px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 20;
  font-family: var(--mono);
  font-size: clamp(38px, 7vw, 62px);
  font-weight: 760;
  letter-spacing: 1px;
  color: #a6cbff;
  text-shadow: 0 0 26px rgba(90,141,255,.22);
  pointer-events: none;
  user-select: none;
}

.title .by-line {
  font-size: clamp(15px, 3vw, 26px);
}

.level{
  position:fixed;
  left:14px;
  top:24px;
  z-index: 20;
  font-size:13px;
  letter-spacing:.25px;
  color:var(--muted);
  font-weight:700;
}

.meta{
  width: min(calc(var(--N) * var(--cell) + 34px), 100%);
  margin: 0 auto 10px;
  display:flex;
  justify-content:space-between;
  align-items: baseline;
  gap:18px;
}

.score{
  font-size: 38px;
  font-weight: 820;
  line-height: 1;
  color: #65adff;
  text-shadow: 0 0 20px rgba(101,173,255,.2);
}

.timer{
  font-family:var(--mono);
  font-size: 30px;
  font-weight: 740;
  color: #ffd35a;
  line-height: 1;
  text-shadow: 0 0 16px rgba(255,211,90,.2);
}

.toggle{
  position:fixed;
  right:14px;
  top:22px;
  z-index: 20;
  display:flex;
  align-items:center;
  gap:10px;
  font-family:var(--mono);
  font-size:14px;
  font-weight:700;
  color:var(--muted);
  user-select:none;
}
.modeLabel{
  letter-spacing:.35px;
  opacity:.55;
  transition:opacity .16s ease, color .16s ease;
}
.toggle.easy .modeLabel.easy{
  opacity:1;
  color:#8ae9b7;
}
.toggle.hard .modeLabel.hard{
  opacity:1;
  color:#ffb18f;
}
.switch{
  width:74px;
  height:34px;
  border-radius:999px;
  border:1px solid var(--gridline);
  position:relative;
  cursor:pointer;
  background: rgba(255,255,255,.05);
}
.switch::after{
  content:"";
  width:28px;
  height:28px;
  border-radius:50%;
  background:#fff;
  position:absolute;
  top:2px;
  left:2px;
  transition:transform .16s ease;
}
.switch.on::after{ transform:translateX(40px); }

/* Target in the middle */
.targetWrap{
  position:relative;
  height:64px;
  margin: 6px 0 12px;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow: visible;
}

.target{
  font-family:var(--mono);
  font-size:40px;
  font-weight:460;
  letter-spacing:.35px;
  line-height:1;
  will-change: transform, opacity;
  text-rendering: geometricPrecision;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.target.in{ animation: targetIn .26s ease-out 1; }
@keyframes targetIn{
  from { transform: translateX(calc(-100vw - 320px)); opacity: 0; }
  to   { transform: translateX(0); opacity: 1; }
}

.target.out{ animation: targetOut .22s ease-in 1 forwards; }
@keyframes targetOut{
  from { transform: translateX(0); opacity: 1; }
  to   { transform: translateX(calc(100vw + 320px)); opacity: 0; }
}

.target.success{
  color: #58ffb4;
  text-shadow: 0 0 18px rgba(88,255,180,.25);
}

.target.fail{
  color: var(--failText);
  animation: targetFail .82s cubic-bezier(.2,.9,.2,1) 1 forwards;
  transform-origin: 50% 30%;
}
@keyframes targetFail{
  0%   { transform: translateY(0) rotate(0); opacity: 1; }
  18%  { transform: translateY(0) rotate(-10deg); }
  35%  { transform: translateY(0) rotate(11deg); }
  52%  { transform: translateY(0) rotate(-9deg); }
  70%  { transform: translateY(22px) rotate(8deg); }
  100% { transform: translateY(calc(100vh + 180px)) rotate(42deg); opacity: 0; }
}

/* Board checkerboard (subtle) */
.boardWrap{
  position:relative;
  display:flex;
  justify-content:center;
  width: min(calc(var(--N) * var(--cell) + 34px), 100%);
  margin: 0 auto;
  padding: 14px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.06);
  background: rgba(255,255,255,.02);
}

/* Grid */
.grid{
  display:grid;
  grid-template-columns:repeat(var(--N),var(--cell));
  border:2px solid var(--gridline);
  border-radius: 12px;
  overflow:hidden;
  user-select:none;
  touch-action:none;
  background-color: rgba(255,255,255,.02);
  background-image:
    linear-gradient(45deg, rgba(255,255,255,.042) 25%, rgba(255,255,255,.010) 25%, rgba(255,255,255,.010) 75%, rgba(255,255,255,.042) 75%, rgba(255,255,255,.042)),
    linear-gradient(45deg, rgba(255,255,255,.042) 25%, rgba(255,255,255,.010) 25%, rgba(255,255,255,.010) 75%, rgba(255,255,255,.042) 75%, rgba(255,255,255,.042));
  background-size: calc(var(--cell) * 2) calc(var(--cell) * 2);
  background-position: 0 0, var(--cell) var(--cell);
}

.cell{
  width:var(--cell);
  height:var(--cell);
  display:flex;
  align-items:center;
  justify-content:center;
  font-family:var(--matrix);
  font-size:var(--font);
  font-weight:100;
  font-optical-sizing: auto;
  font-synthesis-weight: none;
  font-variant-numeric: tabular-nums;
  letter-spacing:.08px;
  color: rgba(242,248,255,.98);
  font-stretch: condensed;
  text-rendering: optimizeLegibility;
  border-right:1px solid var(--gridline);
  border-bottom:1px solid var(--gridline);
  cursor:pointer;          /* pointer cursor */
  touch-action:none;
  will-change: transform, opacity;
  background: transparent;
}

.cell.drag{ background:var(--drag); }
.cell.ok{ background:var(--ok); }
.cell.reveal{ background:var(--reveal); }
.cell.bad{ background:var(--bad); }
.cell.hint{
  background: var(--gold);
  box-shadow: inset 0 0 0 1px rgba(255,208,90,.5);
}

.cell.turnBlast{
  animation: turnBlast .3s ease-in forwards;
}
@keyframes turnBlast{
  from { transform: translateY(0) rotate(0) scale(1); opacity:1; }
  to   { transform: translateY(var(--yj)) rotate(var(--rj)) scale(1.16); opacity:0; }
}
.cell.slot{
  animation: slot .26s ease-out forwards;
}
@keyframes slot{
  from { transform: translateY(-42%) scaleY(1.18); filter: blur(1.4px); opacity:.46; }
  to   { transform: translateY(0) scaleY(1); filter: blur(0); opacity:1; }
}

/* Board explode/assemble */
.cell.explode{
  animation: explode .36s ease-in 1 forwards;
}
@keyframes explode{
  from { transform: translate(0,0) rotate(0); opacity: 1; }
  to   { transform: translate(var(--tx), var(--ty)) rotate(var(--rot)); opacity: 0; }
}

.cell.assemble{
  animation: assemble .34s ease-out 1 forwards;
}
@keyframes assemble{
  from { transform: translate(var(--tx), var(--ty)) rotate(var(--rot)); opacity: 0; }
  to   { transform: translate(0,0) rotate(0); opacity: 1; }
}

/* Sparks */
.sparks{
  position:absolute;
  inset:0;
  pointer-events:none;
  overflow:visible;
}
.spark{
  position:absolute;
  width:6px;
  height:2px;
  border-radius:999px;
  background: rgba(255, 210, 92, .95);
  box-shadow: 0 0 10px rgba(255,210,92,.55);
  transform-origin: 0 50%;
  animation: spark .55s ease-out 1 forwards;
}
@keyframes spark{
  from { transform: translate(0,0) rotate(var(--a)) scaleX(1); opacity: 1; }
  to   { transform: translate(var(--dx), var(--dy)) rotate(var(--a)) scaleX(.6); opacity: 0; }
}

/* Responsive */
@media (max-width:760px){
  body{
    align-items:flex-start;
  }
  .app{
    max-width:100%;
    padding: calc(144px + env(safe-area-inset-top, 0px)) 10px 12px;
  }
  .title{
    top: calc(4px + env(safe-area-inset-top, 0px));
    font-size: clamp(32px, 10vw, 50px);
    letter-spacing:.45px;
    width: 100%;
    text-align:center;
  }
  .level{
    top: calc(58px + env(safe-area-inset-top, 0px));
    left: 10px;
  }
  .toggle{
    top: calc(54px + env(safe-area-inset-top, 0px));
    right: 10px;
  }
  .targetWrap{
    height:58px;
    margin:2px 0 8px;
  }
  .target{
    font-size: clamp(30px, 9vw, 38px);
  }
  .meta{
    margin: 0 auto 8px;
    gap:12px;
  }
  .score{ font-size:32px; }
  .timer{ font-size:24px; }
  .boardWrap{
    padding: 10px;
    border-radius: 12px;
  }
  .instructions{
    margin: 8px auto 0;
    font-size:12.5px;
    line-height:1.35;
  }
}

@media (max-width:520px){
  .toggle{ top: calc(52px + env(safe-area-inset-top, 0px)); right:8px; font-size:11px; gap:6px; }
  .switch{ width:64px; height:30px; }
  .switch::after{ width:24px; height:24px; }
  .switch.on::after{ transform:translateX(34px); }
  .level{ top: calc(56px + env(safe-area-inset-top, 0px)); left:8px; font-size:12px; }
  .title{ top: calc(4px + env(safe-area-inset-top, 0px)); }
  .target{ font-size: 36px; }
  .timer{ font-size:22px; }
  .score{ font-size:28px; }
}
@media (max-width:390px){
  .app{
    padding: calc(136px + env(safe-area-inset-top, 0px)) 8px 10px;
  }
  .modeLabel{ font-size:10px; }
  .switch{ width:58px; height:28px; }
  .switch::after{ width:22px; height:22px; }
  .switch.on::after{ transform:translateX(30px); }
  .target{ font-size: 34px; }
  .meta{ gap:8px; }
  .timer{ font-size:20px; }
  .score{ font-size:26px; }
}
@media (max-height:700px) and (orientation:landscape){
  .app{
    padding-top: calc(104px + env(safe-area-inset-top, 0px));
  }
  .title{
    font-size: clamp(26px, 6vw, 38px);
  }
  .level{ top: calc(42px + env(safe-area-inset-top, 0px)); }
  .toggle{ top: calc(38px + env(safe-area-inset-top, 0px)); }
}

.instructions{
  margin: 10px auto 0;
  width: min(calc(var(--N) * var(--cell) + 34px), 100%);
  font-size: 13px;
  line-height: 1.4;
  color: var(--muted);
  text-align: center;
}
.trainerLink{
  display:inline-block;
  margin-top:6px;
  color:#8fd8ff;
  text-decoration:none;
  font-weight:700;
  letter-spacing:.2px;
}
.trainerLink:hover{
  color:#b4e9ff;
  text-decoration:underline;
}
</style>
</head>

<body>
<div class="app">
  <div class="top">
    <div class="title">Hectic<br><span class=by-line>Hexadecimal Crossword</span></div>
    <div class="level" id="levelLabel">Level 2</div>
    <div class="toggle easy" id="modeToggle" title="Left EASY, right HARD">
      <span class="modeLabel easy">EASY</span>
      <div class="switch" id="mode"></div>
      <span class="modeLabel hard">HARD</span>
    </div>
  </div>

  <div class="targetWrap">
    <div class="target" id="target">0</div>
    <div class="sparks" id="sparks"></div>
  </div>

  <div class="meta">
    <div class="score">★ <span id="score">0</span></div>
    <div class="timer">⏱ <span id="time">30.0</span></div>
  </div>

  <div class="boardWrap">
    <div class="grid" id="grid"></div>
  </div>

  <div class="instructions">
    Select the square or pattern that represents the number.<br>
    Press H to see hint.
    <br><a class="trainerLink" href="./daily-slam.html">Try Daily Slam IQ Trainer</a>
  </div>
</div>

<script>
(() => {
  const HEX = "0123456789ABCDEF";
  const DEC = "0123456789";
  const DIRS = [
    [ 1, 0], [-1, 0], [0, 1], [0,-1],
    [ 1, 1], [-1,-1], [1,-1], [-1, 1],
  ];

  const ROUND_SECONDS = 30.0;
  const START_LEVEL = 2;
  const LEVEL_STEP_POINTS = 100; // +1 level per 100 points from START_LEVEL

  function inBounds(r,c,N){ return r>=0 && c>=0 && r<N && c<N; }

  // Level config: hidden selection length (K) + board size
  function KForLevel(level){
    // make difficulty direct: level N => N-digit targets (capped)
    return Math.min(7, Math.max(1, level));
  }
  function NForLevel(level){
    const k = KForLevel(level);
    // Smaller K => smaller grid, with K=1 => 7 and max K => 13
    return Math.min(13, Math.max(7, 6 + k));
  }

  // DOM
  const elGrid = document.getElementById("grid");
  const elTarget = document.getElementById("target");
  const elSparks = document.getElementById("sparks");
  const elScore  = document.getElementById("score");
  const elTime   = document.getElementById("time");
  const elMode   = document.getElementById("mode");
  const elToggle = document.getElementById("modeToggle");
  const elLevel  = document.getElementById("levelLabel");

  // State
  let mode = "hex"; // target display only
  let level = START_LEVEL;
  let points = 0;

  let N = NForLevel(level);
  let K = KForLevel(level);     // hidden
  let grid = [];

  // Guaranteed solution (for solvability); user can match ANY selection that equals the target
  let chosenSolution = []; // [{r,c}...]
  let chosenHex = "";
  let chosenDec = "";
  let targetValue = 0;

  // Interaction
  let dragging = false;
  let dragStart = null;
  let dragPath = [];
  let locked = false;

  // Timer
  let seconds = ROUND_SECONDS;
  let timerId = null;
  let hintId = null;
  let tableMode = "dec";
  const secureCrypto = globalThis.crypto;

  function sleep(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  function assertSecureRng(){
    if(!secureCrypto || typeof secureCrypto.getRandomValues !== "function"){
      throw new Error("Secure RNG unavailable: crypto.getRandomValues is required.");
    }
  }
  function secureUint32(){
    const a = new Uint32Array(1);
    secureCrypto.getRandomValues(a);
    return a[0];
  }
  function randInt(maxExclusive){
    if(maxExclusive <= 0) return 0;
    const full = 0x100000000;
    const limit = Math.floor(full / maxExclusive) * maxExclusive;
    let x = 0;
    do { x = secureUint32(); } while(x >= limit);
    return x % maxExclusive;
  }
  function randIntRange(minInclusive, maxInclusive){
    return minInclusive + randInt((maxInclusive - minInclusive + 1));
  }

  function boardAlphabet(){
    return (tableMode === "dec") ? DEC : HEX;
  }
  function randBoardChar(){
    const alpha = boardAlphabet();
    return alpha[randInt(alpha.length)];
  }
  function pathValueFromString(s){
    if(!s) return NaN;
    return parseInt(s, tableMode === "dec" ? 10 : 16);
  }
  function syncModes(nextMode){
    mode = nextMode;
    tableMode = (mode === "hex") ? "dec" : "hex";
    const hard = (mode === "dec");
    elMode.classList.toggle("on", hard);
    elToggle.classList.toggle("hard", hard);
    elToggle.classList.toggle("easy", !hard);
  }
  function targetText(){
    return (mode === "hex") ? ("0x" + chosenHex) : chosenDec;
  }
  function rebuildRoundForModeSwitch(){
    dragging = false;
    dragStart = null;
    dragPath = [];
    clearAllMarks();
    if(hintId){
      clearTimeout(hintId);
      hintId = null;
    }
    buildGrid(true);
    pickSolvableTarget();
    startTimer();
  }

  // ---------- UI ----------
  function updateTopUI(){
    elScore.textContent = String(Math.floor(points));
    elLevel.textContent = `Level ${level}`;
  }

  function renderTarget(){
    // animate in each time we set a new target
    elTarget.classList.remove("in","out","fail","success");
    elTarget.style.color = "";
    elTarget.textContent = targetText();
    // kick in animation
    void elTarget.offsetWidth;
    elTarget.classList.add("in");
  }

  function displayForCell(hexDigit){
    return (tableMode === "dec") ? String(hexDigit) : hexDigit;
  }
  function targetFitsMode(v){
    if(!Number.isFinite(v) || v < 0) return false;
    const max = (mode === "dec") ? ((10 ** K) - 1) : ((16 ** K) - 1);
    const min = (K <= 1) ? 0 : ((mode === "dec") ? (10 ** (K - 1)) : (16 ** (K - 1)));
    return v >= min && v <= max;
  }

  function waitAnim(el){
    return new Promise(resolve => {
      const done = () => { el.removeEventListener("animationend", done); resolve(); };
      el.addEventListener("animationend", done, { once:true });
    });
  }

  // ---------- Grid ----------
  function buildGrid(withAssemble=false){
    grid = new Array(N);
    elGrid.innerHTML = "";
    document.documentElement.style.setProperty("--N", N);

    for(let r=0;r<N;r++){
      grid[r] = new Array(N);
      for(let c=0;c<N;c++){
        const d = document.createElement("div");
        d.className = "cell";
        d.dataset.r = r;
        d.dataset.c = c;
        grid[r][c] = randBoardChar();
        d.textContent = displayForCell(grid[r][c]);

        // remove borders on last row/col
        if(c === N-1) d.style.borderRight = "none";
        if(r === N-1) d.style.borderBottom = "none";

        if(withAssemble){
          // start from scattered positions
          d.classList.add("assemble");
          d.style.setProperty("--tx", randIntRange(-220,220) + "px");
          d.style.setProperty("--ty", randIntRange(-220,220) + "px");
          d.style.setProperty("--rot", randIntRange(-40,40) + "deg");
        }

        elGrid.appendChild(d);
      }
    }
  }

  function cellEl(r,c){
    return elGrid.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
  }

  function clearMarks(cls){
    elGrid.querySelectorAll(".cell."+cls).forEach(x => x.classList.remove(cls));
  }

  function clearAllMarks(){
    ["drag","ok","bad","reveal","hint","turnBlast","slot"].forEach(clearMarks);
  }

  // ---------- Target picking ----------
  function pickSolvableTarget(){
    for(let tries=0; tries<8000; tries++){
      const r0 = randInt(N);
      const c0 = randInt(N);
      const [dx,dy] = DIRS[randInt(DIRS.length)];

      const rEnd = r0 + dy*(K-1);
      const cEnd = c0 + dx*(K-1);
      if(!inBounds(rEnd,cEnd,N)) continue;

      let s = "";
      const cells = [];
      for(let i=0;i<K;i++){
        const r = r0 + dy*i;
        const c = c0 + dx*i;
        s += grid[r][c];
        cells.push({r,c});
      }

      // Keep Level 1 extra snappy: prefer smaller targets (bias away from huge decimals)
      const v = pathValueFromString(s);
      if(!Number.isFinite(v)) continue;
      if(level === 1 && v > 40) continue; // makes L1 feel faster/cleaner
      if(!targetFitsMode(v)) continue;

      chosenSolution = cells;
      chosenHex = v.toString(16).toUpperCase();
      chosenDec = String(v);
      targetValue = v;
      renderTarget();
      return;
    }

    // fallback
    chosenSolution = [{r:0,c:0}];
    const fallbackS = grid[0][0];
    targetValue = pathValueFromString(fallbackS) || 0;
    chosenHex = targetValue.toString(16).toUpperCase();
    chosenDec = String(targetValue);
    renderTarget();
  }

  // ---------- Timer ----------
  function stopTimer(){
    if(timerId){ clearInterval(timerId); timerId = null; }
  }

  function startTimer(){
    stopTimer();
    seconds = ROUND_SECONDS;
    elTime.textContent = seconds.toFixed(1);

    timerId = setInterval(() => {
      if(locked) return;
      seconds = Math.max(0, seconds - 0.1);
      elTime.textContent = seconds.toFixed(1);
      if(seconds <= 0){
        timeoutReveal();
      }
    }, 100);
  }

  // ---------- Selection math ----------
  function normalizeDir(dr, dc){
    const sr = Math.sign(dr);
    const sc = Math.sign(dc);
    if(sr === 0 && sc === 0) return null;
    if(sr === 0 || sc === 0) return {dy: sr, dx: sc};
    if(Math.abs(dr) === Math.abs(dc)) return {dy: sr, dx: sc};
    return null;
  }

  function buildFixedLenPath(start, end, len){
    const dr = end.r - start.r;
    const dc = end.c - start.c;
    const dir = normalizeDir(dr, dc);
    if(!dir) return null;

    const path = [];
    for(let i=0;i<len;i++){
      const r = start.r + dir.dy*i;
      const c = start.c + dir.dx*i;
      if(!inBounds(r,c,N)) return null;
      path.push({r,c});
    }
    return path;
  }

  function hexStringOfPath(path){
    let s="";
    for(const {r,c} of path) s += grid[r][c];
    return s;
  }

  function markPath(path, cls){
    for(const {r,c} of path){
      const ce = cellEl(r,c);
      if(ce) ce.classList.add(cls);
    }
  }

  // ---------- Animations / FX ----------
  function spawnSparks(){
    // small golden burst around target
    const rect = elTarget.getBoundingClientRect();
    const wrap = elSparks.getBoundingClientRect();
    const cx = rect.left - wrap.left + rect.width/2;
    const cy = rect.top  - wrap.top  + rect.height/2;

    for(let i=0;i<14;i++){
      const sp = document.createElement("div");
      sp.className = "spark";
      const a = randInt(360);
      const dist = randIntRange(30,74);
      const dx = Math.cos(a*Math.PI/180) * dist;
      const dy = Math.sin(a*Math.PI/180) * dist;
      sp.style.left = (cx|0) + "px";
      sp.style.top  = (cy|0) + "px";
      sp.style.setProperty("--a", a + "deg");
      sp.style.setProperty("--dx", dx.toFixed(0) + "px");
      sp.style.setProperty("--dy", dy.toFixed(0) + "px");
      elSparks.appendChild(sp);
      sp.addEventListener("animationend", () => sp.remove(), { once:true });
    }
  }

  async function targetExitRight(){
    elTarget.classList.remove("in","fail","out");
    void elTarget.offsetWidth;
    elTarget.classList.add("out");
    await waitAnim(elTarget);
  }

  async function targetFailFall(){
    elTarget.classList.remove("in","out","success","fail");
    void elTarget.offsetWidth;
    elTarget.classList.add("fail");
    await waitAnim(elTarget);
  }

  async function explodeBoard(){
    const cells = [...elGrid.querySelectorAll(".cell")];
    cells.forEach(c => {
      c.classList.remove("assemble");
      c.style.setProperty("--tx", randIntRange(-260,260) + "px");
      c.style.setProperty("--ty", randIntRange(-260,260) + "px");
      c.style.setProperty("--rot", randIntRange(-60,60) + "deg");
      c.classList.add("explode");
    });

    // wait roughly for explode animation
    await new Promise(r => setTimeout(r, 380));
  }

  async function explodeAndSlotPath(path){
    const targets = [];
    for(const pt of path){
      const ce = cellEl(pt.r, pt.c);
      if(!ce) continue;
      targets.push({ ...pt, ce });
    }
    if(!targets.length) return;

    for(const t of targets){
      t.ce.classList.remove("turnBlast", "slot");
      t.ce.style.setProperty("--rj", randIntRange(-15,15) + "deg");
      t.ce.style.setProperty("--yj", randIntRange(8,24) + "px");
      void t.ce.offsetWidth;
      t.ce.classList.add("turnBlast");
    }
    await sleep(310);

    for(const t of targets){
      t.ce.classList.remove("turnBlast","drag","ok","bad","reveal","hint");
      t.ce.classList.add("slot");
    }
    for(let i=0;i<6;i++){
      for(const t of targets){
        grid[t.r][t.c] = randBoardChar();
        t.ce.textContent = displayForCell(grid[t.r][t.c]);
      }
      await sleep(54);
    }
    await sleep(150);
    for(const t of targets){
      t.ce.classList.remove("slot");
    }
  }

  async function revealSolutionOrdered(holdMs=3000, stepMs=220){
    clearAllMarks();
    for(const pt of chosenSolution){
      markPath([pt], "reveal");
      await sleep(stepMs);
    }
    await sleep(holdMs);
  }

  function showHint(){
    if(locked || !chosenSolution.length || seconds <= 0) return;

    seconds = Math.max(0.1, seconds * 0.5);
    elTime.textContent = seconds.toFixed(1);

    if(hintId){
      clearTimeout(hintId);
      hintId = null;
    }

    elGrid.querySelectorAll(".cell.hint").forEach(cell => cell.classList.remove("hint"));
    const first = chosenSolution[0];
    const ce = cellEl(first.r, first.c);
    if(!ce) return;
    ce.classList.add("hint");
    hintId = setTimeout(() => {
      ce.classList.remove("hint");
      hintId = null;
    }, 850);
  }

  // ---------- Progression ----------
  function maybeLevelUp(){
    const nextLevel = START_LEVEL + Math.floor(points / LEVEL_STEP_POINTS);
    if(nextLevel <= level) return false;

    // level-up
    level = nextLevel;
    updateTopUI();

    spawnSparks();

    const newN = NForLevel(level);
    const newK = KForLevel(level);

    const boardSizeChanged = (newN !== N);
    N = newN;
    K = newK;

    return boardSizeChanged;
  }

  // ---------- Outcomes ----------
  async function onSuccess(path){
    locked = true;
    stopTimer();

    // score = time remaining * K
    const add = Math.max(0, seconds) * K;
    points += add;
    updateTopUI();

    // mark success
    clearAllMarks();
    markPath(path, "ok");
    elTarget.classList.remove("fail");
    elTarget.classList.add("success");
    await sleep(1000);

    // target exits right
    await targetExitRight();

    // explode used cells, then slot-in new values
    await explodeAndSlotPath(path);
    clearAllMarks();

    // level-up check + board rebuild animation if needed
    const boardChanged = maybeLevelUp();
    if(boardChanged){
      await explodeBoard();
      buildGrid(true); // assemble animation
    }

    // new target slides in
    pickSolvableTarget();
    locked = false;
    startTimer();
  }

  async function onFail(path){
    locked = true;
    stopTimer();

    clearAllMarks();
    markPath(path, "bad");
    await sleep(280);

    // target tumbles down to viewport bottom
    await targetFailFall();

    // show correct sequence in order, then hold full reveal
    clearAllMarks();
    await revealSolutionOrdered(3000, 220);

    // explode revealed truth path, then slot-in new values
    await explodeAndSlotPath(chosenSolution);
    clearAllMarks();
    pickSolvableTarget();
    locked = false;
    startTimer();
  }

  async function timeoutReveal(){
    locked = true;
    stopTimer();

    clearAllMarks();
    await revealSolutionOrdered(1700, 200);
    await targetFailFall(); // same “fall” on timeout feels consistent

    await explodeAndSlotPath(chosenSolution);
    clearAllMarks();

    pickSolvableTarget();
    locked = false;
    startTimer();
  }

  // ---------- Pointer handling (fully clickable) ----------
  function cellFromPoint(clientX, clientY){
    const raw = document.elementFromPoint(clientX, clientY);
    if(!raw) return null;
    const cell = raw.closest?.(".cell");
    if(!cell) return null;
    return { r: +cell.dataset.r, c: +cell.dataset.c };
  }

  function onPointerDown(e){
    if(locked) return;
    const p = cellFromPoint(e.clientX, e.clientY);
    if(!p) return;

    dragging = true;
    dragStart = p;
    dragPath = [p];

    elGrid.setPointerCapture?.(e.pointerId);

    clearMarks("drag");
    markPath(dragPath, "drag");
    e.preventDefault();
  }

  function onPointerMove(e){
    if(!dragging || locked || !dragStart) return;
    const p = cellFromPoint(e.clientX, e.clientY);
    if(!p) return;

    const path = buildFixedLenPath(dragStart, p, K);
    if(!path) return;

    dragPath = path;
    clearMarks("drag");
    markPath(dragPath, "drag");
    e.preventDefault();
  }

  function onPointerUp(e){
    if(!dragging || locked) return;
    dragging = false;

    clearMarks("drag");

    if(!dragPath || dragPath.length !== K){
      dragStart = null;
      dragPath = [];
      return;
    }

    const s = hexStringOfPath(dragPath);
    const v = pathValueFromString(s);

    // Respect their pull: ANY selection that equals the target is a win.
    if(v === targetValue){
      onSuccess(dragPath);
    } else {
      onFail(dragPath);
    }

    dragStart = null;
    dragPath = [];
    e.preventDefault();
  }

  // ---------- Toggle ----------
  elToggle.addEventListener("click", () => {
    if(locked) return;
    syncModes((mode === "dec") ? "hex" : "dec");
    rebuildRoundForModeSwitch();
  });

  // Listeners
  elGrid.addEventListener("pointerdown", onPointerDown, {passive:false});
  window.addEventListener("pointermove", onPointerMove, {passive:false});
  window.addEventListener("pointerup", onPointerUp, {passive:false});
  window.addEventListener("pointercancel", onPointerUp, {passive:false});
  window.addEventListener("keydown", (e) => {
    if(e.repeat) return;
    if(e.key === "h" || e.key === "H"){
      showHint();
      e.preventDefault();
    }
  });

  // ---------- Boot ----------
  function boot(){
    N = NForLevel(level);
    K = KForLevel(level);

    assertSecureRng();
    syncModes(mode);
    buildGrid(true); // assemble on load is nice
    updateTopUI();
    pickSolvableTarget();
    startTimer();
  }

  boot();
})();
</script>
</body>
</html>
